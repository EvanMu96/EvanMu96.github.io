<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Komoriii</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Komoriii">
<meta property="og:url" content="http://blog.senevan.com/page/2/index.html">
<meta property="og:site_name" content="Komoriii">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Komoriii">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Komoriii" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Komoriii</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/About-Me">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.senevan.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2020-03-25" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/25/2020-03-25/" class="article-date">
  <time class="dt-published" datetime="2020-03-24T16:22:56.000Z" itemprop="datePublished">2020-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/25/2020-03-25/">[LeetCode] 数组的区间信息类型题目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>之前在知乎上看到有算法竞赛经历的同学曾经提到过「线段树」「树状数组」这两种特殊的树型数据结构, 后来19年找工作前在leetcode上联系发现每次遇到维护区间信息的题目的时候有可以用到这几种数据结构,因此随手记两道典型的题目用于备忘.</p>
<h2 id="线段树-307-Range-Sum-Query-Mutable"><a href="#线段树-307-Range-Sum-Query-Mutable" class="headerlink" title="线段树: 307. Range Sum Query - Mutable"></a>线段树: 307. Range Sum Query - Mutable</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p>
<p>update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Given nums &#x3D; [1, 3, 5]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 9</span><br><span class="line">update(1, 2)</span><br><span class="line">sumRange(0, 2) -&gt; 8</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>数组仅可以在 update 函数下进行修改。<br>你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-mutable">https://leetcode-cn.com/problems/range-sum-query-mutable</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>线段树也是一种二叉搜索树。线段树有一个特点是，只有leaf节点是实在的元素，而其余的节点都表示多个元素的和。线段树使用的场景也是用来存储可以做区间加法的元素，并且需要大量地计算某个区间的和，而不是取具体某个节点的值「因为需要直接取值干脆就用vector了，可以O(1)随机存取」。下图是一个非常简单的线段树的例子，蓝色节点表示是多个节点的和，橙色的节点表示的是叶节点，与题目中的num相对应。</p>
<p>线段树相比于一般的二叉搜索树的游戏在于，在查询一个区间的和的时候有着O（logN）的时间复杂度。</p>
<p><img src="/images/segmenttreedemo.png" alt="segmenttreedemo"></p>
<p>构建一棵线段树可以从任意一个空或非空的数组/向量开始，后续可以使用update(i, val)方法修改index为i的叶节点的值为val「我们由于在线段树中删除和添加的操作，实际的语义都是添加一个线段/删除一个线段，并且涉及到在查询的时候查询的区间可能并不构成一个线段，比如查询0<del>10但是实际是0</del>5和8~10两个线段，所以对于添加和删除暂且不做深入」。</p>
<p>回归到LeetCode 307这一道题目，下面我给出的代码大致上参考了花花的LeetCode307教程[2]。我个人非常推荐在找工作的同学去看花花的Youtube频道或者他个人网站上的思路讲解, 我对于DP的入门就是来自他的视频讲解.</p>
<details>
  <summary>点击查看代码</summary>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 一种特殊的二叉搜索树 线段树</span></span><br><span class="line"><span class="comment">// 线段树的树叶节点是真实插入的元素 其余的节点都表示一个区间和</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SegmentTreeNode</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> sum = <span class="number">0</span>, SegmentTreeNode* left = <span class="literal">nullptr</span>,</span><br><span class="line">                                                 SegmentTreeNode* right = <span class="literal">nullptr</span>):</span><br><span class="line">        <span class="built_in">start</span>(start), <span class="built_in">end</span>(end), <span class="built_in">sum</span>(sum), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">    <span class="built_in">SegmentTreeNode</span>(<span class="keyword">const</span> SegmentTreeNode&amp;) = <span class="keyword">delete</span>; <span class="comment">// disable copy construction</span></span><br><span class="line">    SegmentTreeNode&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SegmentTreeNode&amp;) = <span class="keyword">delete</span>; <span class="comment">// disable asssignment</span></span><br><span class="line">    ~<span class="built_in">SegmentTreeNode</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> left;</span><br><span class="line">        <span class="keyword">delete</span> right;</span><br><span class="line">        left = right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start; <span class="comment">// start of index</span></span><br><span class="line">    <span class="keyword">int</span> end; <span class="comment">// end of index (included)</span></span><br><span class="line">    <span class="keyword">int</span> sum; <span class="comment">// sum of the range</span></span><br><span class="line">    SegmentTreeNode* left; <span class="comment">// left subTree</span></span><br><span class="line">    SegmentTreeNode* right; <span class="comment">// right subTree</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        nums_.<span class="built_in">swap</span>(nums);</span><br><span class="line">        <span class="keyword">if</span>(!nums_.<span class="built_in">empty</span>()) root_.<span class="built_in">reset</span>(<span class="built_in">buildTree</span>(<span class="number">0</span>, nums_.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">updateTree</span>(root_.<span class="built_in">get</span>(), i, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sumRange</span>(root_.<span class="built_in">get</span>(), i, j);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums_;</span><br><span class="line">    std::unique_ptr&lt;SegmentTreeNode&gt; root_;</span><br><span class="line">    <span class="comment">// initialize a SegmentTree</span></span><br><span class="line">    <span class="function">SegmentTreeNode* <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="comment">// only 1 element, this is a leaf node</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Build a leaf: &quot;</span> &lt;&lt; nums_[start] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegmentTreeNode</span>(start, end, nums_[start]);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">buildTree</span>(start, mid);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">buildTree</span>(mid + <span class="number">1</span>, end);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Build a non-leaf, the sum is:&quot;</span> &lt;&lt; left-&gt;sum + right-&gt;sum &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">SegmentTreeNode</span>(start, end, left-&gt;sum + right-&gt;sum, left, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateTree</span><span class="params">(SegmentTreeNode* root, <span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;start == i &amp;&amp; root-&gt;end == i) &#123;</span><br><span class="line">            root-&gt;sum = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = root-&gt;start + (root-&gt;end - root-&gt;start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= mid) &#123;</span><br><span class="line">            <span class="built_in">updateTree</span>(root-&gt;left, i, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">updateTree</span>(root-&gt;right, i, val);</span><br><span class="line">    </span><br><span class="line">        root-&gt;sum = root-&gt;left-&gt;sum + root-&gt;right-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(SegmentTreeNode* root, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == root-&gt;start &amp;&amp; j == root-&gt;end) <span class="keyword">return</span> root-&gt;sum;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; root-&gt;sum &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="keyword">int</span> mid = root-&gt;start + (root-&gt;end - root-&gt;start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(j &lt;= mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sumRange</span>(root-&gt;left, i, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sumRange</span>(root-&gt;right, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">sumRange</span>(root-&gt;left, i, mid) + <span class="built_in">sumRange</span>(root-&gt;right, mid + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">NumArray <span class="title">n</span><span class="params">(v)</span></span>;</span><br><span class="line">    cout &lt;&lt; n.<span class="built_in">sumRange</span>(<span class="number">0</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    n.<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; n.<span class="built_in">sumRange</span>(<span class="number">0</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h2 id="493-翻转对-Reverse-Pairs"><a href="#493-翻转对-Reverse-Pairs" class="headerlink" title="493. 翻转对 Reverse Pairs"></a>493. 翻转对 Reverse Pairs</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。</p>
<p>你需要返回给定数组中的重要翻转对的数量。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,3,1]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: [2,4,3,5,1]</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">给定数组的长度不会超过50000。</span><br><span class="line">输入数组中的所有数字都在32位整数的表示范围内</span><br></pre></td></tr></table></figure>


<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-pairs">https://leetcode-cn.com/problems/reverse-pairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h3><p>题目要找到所有的在序列中位置靠前但是比靠后的元素大两倍的pair.<br>首先需要介绍树状数组Fenwick Tree.<br>树状数组也是用来维护区间信息的, 但是树状数组要比线段树易于实现很多.它的思路也是用一个大节点表示一些元素的信息,进行查询的时候只要对大节点进行查询就可以减少对树底层元素的访问次数.<br>下图来自OI Wiki<br><img src="https://oi-wiki.org/ds/images/fenwick1.png" alt="oiwiki"><br>八个实边的方框的方块是存入树状数组的8个数,对应到最上层的连续内存块<code>nums</code>(小表从1开始), 他们上面参差不齐的生涯的方块就代表树状数组的区间信息大节点<code>cn</code>. 显然可以看出与<code>c2</code>关联的是<code>nums[1] + num[2]</code>,与<code>c6</code>关联的是<code>nums[5] + nums[6]</code>, 而<code>c8</code>维护着全局的区间信息.<br>有了树状数组,我们可以查询[1,val]之间的整数数量, 对于nums[i]而言, 我们先查询[1, 2*nums[i]]之间的整数数量, 再求出[1, maxvalue]之间的数量, 二者相减就是以i为右端点的翻转对的数量.</p>
<details>
  <summary>点击查看代码</summary>
​```C++
class BIT
{
private:
    vector<int> tree;
    int n;
public:
    BIT(int n): n(n), tree(n+1){}
    static constexpr int lowbit(int x) {return x & (-x);}
    void update(int x, int d)
    {
        while(x <= n)
        {
            tree[x] += d;
            x += lowbit(x);
        }
    }

<pre><code>int query(int x) const 
&#123;
    int ans = 0;
    while(x)
    &#123;
        ans += tree[x];
        x -= lowbit(x);
    &#125;
    return ans;
&#125;
</code></pre>
<p>};</p>
<p>class Solution {<br>public:<br>    int reversePairs(vector<int>&amp; nums) {<br>        set<long long> allNUmbers;<br>        for(int x: nums)<br>        {<br>            allNUmbers.insert(x);<br>            allNUmbers.insert((long long)x*2);<br>        }<br>        // 利用哈希表进行离散化<br>        unordered_map&lt;long long, int&gt; values;<br>        int idx = 0;<br>        for(long long x:allNUmbers) values[x] = ++idx;</p>
<pre><code>    int ret = 0;
    BIT bit(values.size());
    for(int i =0; i &lt; nums.size(); i++)
    &#123;
        int left = values[(long long)nums[i] * 2], right = values.size();
        ret += bit.query(right) - bit.query(left);
        bit.update(values[nums[i]], 1);
    &#125;
    return ret;
&#125;
</code></pre>
<p>};</p>
<p>void trimLeftTrailingSpaces(string &amp;input) {<br>    input.erase(input.begin(), find_if(input.begin(), input.end(), [](int ch) {<br>        return !isspace(ch);<br>    }));<br>}</p>
<p>void trimRightTrailingSpaces(string &amp;input) {<br>    input.erase(find_if(input.rbegin(), input.rend(), [](int ch) {<br>        return !isspace(ch);<br>    }).base(), input.end());<br>}</p>
<p>vector<int> stringToIntegerVector(string input) {<br>    vector<int> output;<br>    trimLeftTrailingSpaces(input);<br>    trimRightTrailingSpaces(input);<br>    input = input.substr(1, input.length() - 2);<br>    stringstream ss;<br>    ss.str(input);<br>    string item;<br>    char delim = ‘,’;<br>    while (getline(ss, item, delim)) {<br>        output.push_back(stoi(item));<br>    }<br>    return output;<br>}</p>
<p>int main() {<br>    string line;<br>    while (getline(cin, line)) {<br>        vector<int> nums = stringToIntegerVector(line);</p>
<pre><code>    int ret = Solution().reversePairs(nums);

    string out = to_string(ret);
    cout &lt;&lt; out &lt;&lt; endl;
&#125;
return 0;
</code></pre>
<p>}</p>
<p>```</p>
</details>
## 区间类题目的其他解法
对于这类区间信息维护的题即便了解上面两种数据结构其实也是可以做的, 方法是通过归并(或者更直接说是写一个归并排序)的同时自底向上计算区间信息, 然后对区间信息做加减法, 不过这种方法也仅仅比暴力每次计算区间信息要好一些而已, 如果要追求更高效的算法还是免不了要了解几种树.
<img src="https://docs.google.com/drawings/d/e/2PACX-1vTZ0_26anaHr0gYiob9nPq8ylkHPN_tE3jsPGVFB-wPWz8Hvek8P_AHW7plaQFe501xo1VeIrhZLN1t/pub?w=960&amp;h=720">

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]<a target="_blank" rel="noopener" href="https://blog.csdn.net/zearot/article/details/52280189">https://blog.csdn.net/zearot/article/details/52280189</a><br>[2]<a target="_blank" rel="noopener" href="https://zxi.mytechroad.com/blog/data-structure/307-range-sum-query-mutable/">https://zxi.mytechroad.com/blog/data-structure/307-range-sum-query-mutable/</a><br>[3]<a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/fenwick/">https://oi-wiki.org/ds/fenwick/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.senevan.com/2020/03/25/2020-03-25/" data-id="ckmivlo21000hf8og36apdclk" data-title="[LeetCode] 数组的区间信息类型题目" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2020-03-05" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/05/2020-03-05/" class="article-date">
  <time class="dt-published" datetime="2020-03-05T13:22:22.000Z" itemprop="datePublished">2020-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/05/2020-03-05/">[LeetCode] 994.腐烂的橘子</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>在给定的网格中，每个单元格可以有以下三个值之一：</p>
<p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>
<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 </p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png"> </p>
<p>输入：<code>[[2,1,1],[1,1,0],[0,1,1]]</code><br>输出：4<br>示例 2：</p>
<p>输入：<code>[[2,1,1],[0,1,1],[1,0,1]]</code><br>输出：-1<br>解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。<br>示例 3：</p>
<p>输入：<code>[[0,2]]</code><br>输出：0<br>解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</p>
<p><em>提示：</em></p>
<p><em>1 &lt;= grid.length &lt;= 10</em><br><em>1 &lt;= grid[0].length &lt;= 10</em><br><em>grid[i][j] 仅为 0、1 或 2</em></p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotting-oranges">https://leetcode-cn.com/problems/rotting-oranges</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>BFS模板题。值得注意的是，这里BFS的起点是多个，因为箱子中一开始可能就有多个坏的橘子。</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箱子中有可能一开始就有多个坏的橘子，所以0level的节点有多个</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_E(x, y, z) (make_pair(x, make_pair(y, z)))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; dir_x = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; dir_y = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bad_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> good_count = <span class="number">0</span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">MAKE_E</span>(<span class="number">0</span>, i, j));</span><br><span class="line">                    bad_count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) good_count++;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> level = p.first;</span><br><span class="line">            <span class="keyword">int</span> _x = p.second.first;</span><br><span class="line">            <span class="keyword">int</span> _y = p.second.second;</span><br><span class="line">            max_level = <span class="built_in">max</span>(level, level);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = _x + dir_x[i];</span><br><span class="line">                <span class="keyword">int</span> y = _y + dir_y[i];</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.<span class="built_in">size</span>() &amp;&amp; y &gt;=<span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">MAKE_E</span>(level+<span class="number">1</span>, x, y));</span><br><span class="line">                    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                    good_count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> good_count == <span class="number">0</span> ? max_level : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>(grid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.senevan.com/2020/03/05/2020-03-05/" data-id="ckmivlo20000ff8oge1zt5vuy" data-title="[LeetCode] 994.腐烂的橘子" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2019-02-26" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/26/2019-02-26/" class="article-date">
  <time class="dt-published" datetime="2020-02-25T17:17:51.000Z" itemprop="datePublished">2020-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/26/2019-02-26/"> [东拼西凑] AC自动机算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近在看龙书<em>Compilers, Principles, Techniques, and Tools</em>，涉及到了一点关于字符串匹配/正则表达式/自动机理论的知识。在词法分析这一章节介绍了一个字符串匹配算法AC自动机，我觉得它理解起来并不是很难，只是一个过去算法的综合。所以尝试写一篇文章来介绍这个算法。顺便做一点coding练习。</p>
<p>AC自动机算法「Aho-Corasick」是一个通过构建一个代表trie的finite-state machine的字符串/字典匹配算法。要介绍它离不开介绍一个更常见的算法KMP和一种字典数据结构trie树。</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>时间复杂度O(m+n) m for string length, n for pattern length</p>
<p>说到从一个序列中匹配一个目标字符串，最简单的办法就是把序列中的每一个字符作为起点，向后试探是否能够与目标字符串匹配，一旦是不匹配就将起点向后移一位。</p>
<img src="/Users/komoriii/Documents/GitHub/EvanMu96.github.io/public/images/problem1.png" style="zoom:50%;" />

<p>这种最接近brute-force的算法，也可以用一个DFA来描述。如果每次读取的一个字符是pattern匹配的下一个字符，那么移动到下一个状态，但是每次都是回到0号状态，导致时间复杂度是O(mn)。</p>
<p><img src="/images/bfsm.png"></p>
<p>KMP算法要解决的问题就是，如何尽可能回退更少的状态。所以引入了一个映射叫做失效函数。根据pattern的特性，每一个pattern有着不同的失效函数。失效函数f(s)的目标是使得b1b2…bf(s)是最长的，既是b1b2…bs的真前缀，又是b1b2…bs的后缀子串。这样回退的状态就不再是一股脑地回退到0号状态，而是回退到号码是f(s)的状态。</p>
<p>对于ababaaa 失效函数是这样构造的</p>
<table>
<thead>
<tr>
<th>s</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>f(s)</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>对于ababaaa的KMP版本的DFA是这样的</p>
<p><img src="/images/kmpsm.png" alt="kmpsm"></p>
<p>构造这样一个失效函数可以用如下的算法，找到每一个s对应的f(s)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;伪代码 仅用来描述算法</span><br><span class="line">&#x2F;&#x2F;pseudocode for s-&gt;f(s) generatiion</span><br><span class="line">b &#x3D; &quot;some string&quot;</span><br><span class="line">t &#x3D; 0;</span><br><span class="line">f[1] &#x3D; 0; &#x2F;&#x2F;</span><br><span class="line">for(s&#x3D;1; s&lt;n; s++)&#123;</span><br><span class="line">	while(t&gt;0&amp;&amp;b[s+1]! &#x3D; b[t+1]) t &#x3D; f(t);</span><br><span class="line">	if(b[s+1] &#x3D;&#x3D; b[t+1])&#123;</span><br><span class="line">		t&#x3D;t+1;</span><br><span class="line">		f[s+1]&#x3D;t;</span><br><span class="line">	&#125;</span><br><span class="line">	else f[s+1] &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>Trie树也叫做前缀树。它是一种搜索树，但是与二分搜索树不同的是，它的key不保存在节点中，而是与这个节点在树中的位置直接相关的。</p>
<p>比如一个存储了4个key的trie树是这样的。</p>
<p><img src="/images/trie.png" alt="trie"></p>
<h2 id="Aho-Corasick算法"><a href="#Aho-Corasick算法" class="headerlink" title="Aho-Corasick算法"></a>Aho-Corasick算法</h2><p>Aho「龙书的作者」和Corasick对KMP算法进行了推广，当我们知道一个pattern字典(a set of patterns)，这些pattern就可以组合成一个trie树。同时，由于KMP的失效函数的思想，在这样一个trie树的结构下就可以在不同的分支「即是不同的pattern」之间转移状态。</p>
<p><img src="/images/acsm.png" alt="acsm"></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>实现Aho-Corasic算法首先要构建一个Trie树（如何实现一个Trie树可以参考维基百科的Trie词条或者LeetCode <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a> (这是LeetCode中国的链接，题号与国际版本相同)），然后修改节点添加失效函数，也就是匹配失效时候状态转移的轨迹。<br>下面的C++代码实现主要来自: <a target="_blank" rel="noopener" href="https://cp-algorithms.com/string/aho_corasick.html#toc-tgt-7">https://cp-algorithms.com/string/aho_corasick.html#toc-tgt-7</a> 我仅仅添加了一些注释和测试用例。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span></span><br><span class="line">    <span class="comment">// where to link</span></span><br><span class="line">    <span class="keyword">int</span> next[K];</span><br><span class="line">    <span class="comment">// is it the last character of a word</span></span><br><span class="line">    <span class="keyword">bool</span> leaf = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> pch;</span><br><span class="line">    <span class="keyword">int</span> link = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// where to move buffer</span></span><br><span class="line">    <span class="keyword">int</span> go[K];</span><br><span class="line">    <span class="comment">// default parameters lead to a root</span></span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="keyword">int</span> p=<span class="number">-1</span>, <span class="keyword">char</span> ch=<span class="string">&#x27;$&#x27;</span>) : <span class="built_in">p</span>(p), <span class="built_in">pch</span>(ch) &#123;</span><br><span class="line">        <span class="comment">// initialized all direction into -1</span></span><br><span class="line">        <span class="built_in">fill</span>(<span class="built_in">begin</span>(next), <span class="built_in">end</span>(next), <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(<span class="built_in">begin</span>(go), <span class="built_in">end</span>(go), <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Vertex&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_string</span><span class="params">(string <span class="keyword">const</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (t[v].next[c] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// append a new Vertex </span></span><br><span class="line">            t[v].next[c] = t.<span class="built_in">size</span>();</span><br><span class="line">            t.<span class="built_in">emplace_back</span>(v, ch);</span><br><span class="line">        &#125;</span><br><span class="line">        v = t[v].next[c];   </span><br><span class="line">    &#125;</span><br><span class="line">    t[v].leaf = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_link</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[v].link == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">0</span> || t[v].p == <span class="number">0</span>)</span><br><span class="line">            t[v].link = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// recursively find the parent and try again</span></span><br><span class="line">            <span class="comment">// until it reachs the root(v = 0)</span></span><br><span class="line">            t[v].link = <span class="built_in">go</span>(<span class="built_in">get_link</span>(t[v].p), t[v].pch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t[v].link;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (t[v].go[c] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[v].next[c] != <span class="number">-1</span>)</span><br><span class="line">            t[v].go[c] = t[v].next[c];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// recursively find the parent and try again</span></span><br><span class="line">            <span class="comment">// until it reachs the root(v = 0)</span></span><br><span class="line">            t[v].go[c] = v == <span class="number">0</span> ? <span class="number">0</span> : <span class="built_in">go</span>(<span class="built_in">get_link</span>(v), ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t[v].go[c];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(string <span class="keyword">const</span> &amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123; </span><br><span class="line">        v = <span class="built_in">go</span>(v, obj[i]);</span><br><span class="line">        cout &lt;&lt; t[v].pch &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[v].leaf)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add_string</span>(<span class="string">&quot;tas&quot;</span>);</span><br><span class="line">    <span class="built_in">add_string</span>(<span class="string">&quot;app&quot;</span>);</span><br><span class="line">    <span class="built_in">add_string</span>(<span class="string">&quot;ray&quot;</span>);</span><br><span class="line">    <span class="built_in">add_string</span>(<span class="string">&quot;mac&quot;</span>);</span><br><span class="line">    <span class="built_in">traverse</span>(<span class="string">&quot;taspratray&quot;</span>); <span class="comment">//t a s OK$ r a t r a y OK</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">traverse</span>(<span class="string">&quot;fhduisufdasfdsaseh&quot;</span>); <span class="comment">//$ $ $ $ $ $ $ $ $ a $ $ $ $ a $ $ $ </span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">traverse</span>(<span class="string">&quot;fesafeasmacapp&quot;</span>); <span class="comment">//$ $ $ a $ $ a $ m a c OKa p p OK</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]Wikipedia <em>Trie Tree</em> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Trie">https://en.wikipedia.org/wiki/Trie</a></p>
<p>[2]<em>数据结构(C++语言版)</em> 邓俊辉 「第三版」</p>
<p>[3]<em>Compilers, Principles, Techniques, and Tools 编译原理</em> Alfred V.Aho等 机械工业出版社<br>[3]cp-algorithms.com <a target="_blank" rel="noopener" href="https://cp-algorithms.com/string/aho_corasick.html#">https://cp-algorithms.com/string/aho_corasick.html#</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.senevan.com/2020/02/26/2019-02-26/" data-id="ckmivlo1r0006f8og1ilobcki" data-title=" [东拼西凑] AC自动机算法" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2020-02-15" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/15/2020-02-15/" class="article-date">
  <time class="dt-published" datetime="2020-02-15T13:10:26.000Z" itemprop="datePublished">2020-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/15/2020-02-15/">[编译原理学习笔记] 如何构建一个简单的分支预测语法分析器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>递归下降分析方法（Recursive-descent parsing）是一种 自定向下的 （top-down）的语法分析方法。</p>
<p>预测分析法（Predictive parsing）是递归下降分析方法的一种简单形式。在预测分析法中，各个非终结符号对应的过程中的控制流可以由 lookahead 符号<strong>无二义</strong>地确定。</p>
<p>对类似 C/Java 的文法规则做一些归纳：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stmt -&gt; expr;</span><br><span class="line">			| if(expr) stmt;</span><br><span class="line">			| for(optexpr; optexpr; optexpr) stmt</span><br><span class="line">			| other</span><br><span class="line">optexpr -&gt; ε </span><br><span class="line">			| expr</span><br></pre></td></tr></table></figure>

<p>预测分析法对于一个stmt的lookahead会被初始化为一个非终结符号的第一个终结符号。比如for语句的第一个终结符号就是<code>for</code>。预测分析法的实现框架如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 终结符号类型 terminal</span><br><span class="line">void stmt() &#123;</span><br><span class="line">	switch(lookahead) &#123;</span><br><span class="line">		case tok_expr:</span><br><span class="line">			match(expr);match(&#39;;&#39;);break;</span><br><span class="line">		case tok_if:</span><br><span class="line">			match(tok_if);match(&#39;(&#39;);match(expr);match(&#39;)&#39;);stmt();</span><br><span class="line">			break;</span><br><span class="line">		case tok_for:</span><br><span class="line">			match(tok_for);match(&#39;(&#39;);optexpr();match(&#39;;&#39;)optexpr</span><br><span class="line">	&#125;</span><br><span class="line">	case other:</span><br><span class="line">		match(other); break;</span><br><span class="line">	default:</span><br><span class="line">		&#x2F;&#x2F; raise an syntax error</span><br><span class="line">		break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void optexpr() &#123;</span><br><span class="line">	if(lookahead &#x3D;&#x3D; expr) match(expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void match(terminal t) &#123;</span><br><span class="line">	if(lookahead &#x3D;&#x3D; t) lookahead &#x3D; next_terminal;</span><br><span class="line">	else </span><br><span class="line">	&#x2F;&#x2F; raise an syntax error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建这样的一个预测分析器，要对所有的非终结符定义一个处理的函数。比如上面的stmt和optexpr两个非终结符。</p>
<p>对于非终结符的处理函数，要做下面两件事情：</p>
<ol>
<li>检查lookahead符号，确定要选择哪一个产生式（用一个大 switch 涵盖所有的 case）</li>
<li>对于每一个分支，模拟被选中的产生式的解析过程。</li>
</ol>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1]编译原理(Compilers Principles, Techniques and Tools)， 机械工业出版社</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.senevan.com/2020/02/15/2020-02-15/" data-id="ckmivlo1y000cf8oghirh36ef" data-title="[编译原理学习笔记] 如何构建一个简单的分支预测语法分析器" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2020-02-08" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/08/2020-02-08/" class="article-date">
  <time class="dt-published" datetime="2020-02-08T12:19:17.000Z" itemprop="datePublished">2020-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/08/2020-02-08/">[最近的日常] vol.0</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近在干啥这个系列主要讲讲最近做了什么有意思的事情。流水账偏多。<br>闪2也打完了。如果我没有玩过闪4的话，我相信闪2会对我带来更好的体验。2代最明显的缺陷还是为了推游戏系统把剧情牺牲了，把内战描写硬生生搞成了回合制：找VII班同学，找其他同学，行动解放某地。2代我起手一周目选择了nightmare难度，难度还好，除了克罗斯贝尔的外传部分被黎爷一个疾风两人一起残血。<br>至此，闪之轨迹I II III IV都已经破关。白金的话会从闪3开始，3周目应该能白金（二周目漏了广播话题和不知道哪个宝箱）。<br>———分割线————-<br>这段时间在家打通了闪之轨迹134。在打通1代之后去查了一下，2貌似质量有点不是那么高就直接从1跳到了3。3还是非常好玩的，我连着打的所以并不会因为3的结尾突兀而想骂街。</p>
<p>![英雄傳說 閃之軌跡Ⅲ_20200125160131](/images/英雄傳說 閃之軌跡Ⅲ_20200125160131.jpg)</p>
<p>闪4的???路线大结局真好啊，黎爷他笑容逐渐消失之后终于笑了。</p>
<p>![英雄傳說 閃之軌跡Ⅳ -THE END OF SAGA-_20200207193621](/images/英雄傳說 閃之軌跡Ⅳ -THE END OF SAGA-_20200207193621.jpg)</p>
<p>闪轨1玩的比较咸鱼，有的地方打不过就干脆降低难度了。3代4代玩的时候一周目normal不允许自己翻车降难度，不过3代的破防硬直太长，破防之后只要AT DELAY足够短就可以连到boss再起不能，后面也就没翻车过。4代的话，有时间爆发后游戏难度降低了非常多，魔法攻击的重要性猛增。</p>
<p>今年出《零之轨迹 改》和《碧之轨迹 改》的话试试一周目就选nightmare难度。<br>月初解锁的伊苏9也开始玩了，让人感觉不爽的是伊苏9在城市里的场景掉帧太严重了，明明有些npc连对话都不能要么就删一下让城市的帧数能大部分时间稳60fps也好。伊苏玩的比较慢，我玩8代的时候也是。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.senevan.com/2020/02/08/2020-02-08/" data-id="ckmivlo1x000bf8og8r931fa9" data-title="[最近的日常] vol.0" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Life/" rel="tag">Life</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2020-01-26" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/26/2020-01-26/" class="article-date">
  <time class="dt-published" datetime="2020-01-25T16:09:02.000Z" itemprop="datePublished">2020-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/26/2020-01-26/">[LeetCode] 779. 第K个语法符号</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p><i>在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。</p>
<p>给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）</i></p>
<p>例子:</p>
<p>输入: N = 1, K = 1<br>输出: 0</p>
<p>输入: N = 2, K = 1<br>输出: 0</p>
<p>输入: N = 2, K = 2<br>输出: 1</p>
<p>输入: N = 4, K = 5<br>输出: 1</p>
<p>解释:<br>第一行: 0<br>第二行: 01<br>第三行: 0110<br>第四行: 01101001</p>
<p>注意：</p>
<p>N 的范围 <code>[1, 30]</code>.<br>K 的范围 <code>[1, 2^(N-1)]</code>.</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/k-th-symbol-in-grammar">https://leetcode-cn.com/problems/k-th-symbol-in-grammar</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处</p>
<p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/k-th-symbol-in-grammar/">https://leetcode-cn.com/problems/k-th-symbol-in-grammar/</a></p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>我个人的习惯是遇到一个题会默认用暴力的做法做的，但是这道题用生成第N行字符串的方法最多会生成2^(30-1)=1073741824长度的字符串导致超时。</p>
<p>在看了几份答案之后找到了一个可读性好思路清晰，并且可以学到一些通用的思路的解答方法。</p>
<p>首先当N大于2时，这个字符串时对称的，后半段是前半段的取反。</p>
<p>所以递归就可以这么写了。</p>
<p>base 有两个</p>
<ol>
<li>N == 1 只会返回0</li>
<li>N == 2 如果K==1 返回0否则返回1</li>
</ol>
<p>对于第Nth字符串的长度，是2^(N-1)。当K在[ 0, 2^(N- 1) / 2 ]之间时，这个字符串和N-1th的第K个是相同的。而当K在( 2^(N - 1)/ 2, 2^(N - 1) )之间时，这个字符串时和N-1th的第(K - 2^(N-  1) / 2)个相反的，也就是是对折前半部分的关系。</p>
<p>所以代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">2</span>) <span class="keyword">return</span> K == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> half = <span class="built_in">pow</span>(<span class="number">2</span>, N - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(K &lt;= half)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">kthGrammar</span>(N - <span class="number">1</span>, K);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> - <span class="built_in">kthGrammar</span>(N - <span class="number">1</span>, K - half);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.senevan.com/2020/01/26/2020-01-26/" data-id="ckmivlo1t0008f8ogflg7g0m3" data-title="[LeetCode] 779. 第K个语法符号" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2019-02-08" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/02/08/2019-02-08/" class="article-date">
  <time class="dt-published" datetime="2019-02-08T14:30:23.000Z" itemprop="datePublished">2019-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/02/08/2019-02-08/">[东拼西凑] P and NP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>嗨。It’s been a while.我又一次重新开始写博客了。我这个人对自己留下的幼稚的痕迹曾经十分厌恶，尤其是半途而废的幼稚痕迹。所以我的博客这次已经是第三次重启了，希望这次我能够做到以后看这些东西不会想着赶紧删掉。电影《寻梦环游记》里讲，人有三次死亡，第三次死亡即使被大家所遗忘。我已经从大学中拿着本科和硕士学位毕业，过几年也会加入奔三的队伍中。是时候在人类社会中，或者是在北冰洋的Github备份中给自己留下几个Byte的位置了。<br>新博客的第一篇文章就是补充一篇上一次重启博客没有完成的学习笔记。笔记里的很多内容是参考了吴军博士的《数学之美》，维基百科和知乎上的解答，在这里感谢他们对P/NP这个未解之谜的解释。<br><b/>下面这段文字来自《数学之美》（作者：吴军博士）的附录，偏向于inituition。</b><br>计算机的算法效率是用计算复杂度(Computational Complexity)来衡量的。计算的时间显然和问题的大小有关。比如对10000个实数排序和对1000000个实数排序所用的时间是显然不同的。问题的大小在衡量计算时间复杂度时是变量，一般用N来表示。而计算量是N的一个函数f(N)。这个函数的边界可以用数学上的大O概念来限制。如果两个函数f(N)和g(N)在大O概念上相同，也就是说当N趋近于无穷大时，他们的比值只差一个常数。比如f(N)=N<em>log(N), g(N)=100</em>log(n)，他们就被看做是同一个数量级的。同样，如果两个计算机算法的计算在大O概念下相同，只差一个常数，我们认为它们的计算复杂度相同。计算的复杂度关键看函数而不是这个常数。<br>如果一个算法的计算量是N的多项式函数(Polynomial Function)，则认为这个算法是多项式函数复杂度的。如果一个问题存在一个多项式函数复杂度的算法，则这个问题成为P问题。如果计算量比N的多项式函数还要高，虽然理论上讲如果有无限的时间也是可以计算的（图灵机概念的可计算），但实际上市不可计算的。这时称为非多项式(NP)问题。比如找到每一步围棋的最佳走法就是一个NP问题。<br>如果一个NP问题，虽然找不到多项式函数复杂度的算法，但是对于一个算法可以再多项式函数复杂度的时间内证实这个方法正确与否。那么这个问题成为NP-Complete问题。如果一个问题，它的计算复杂度至少是NP-Complete，那么它被称作NP-Hard问题。换句话讲NPC问题是NP-Hard问题的一个子集。</p>
<p><b/>以下的文字来源于我对维基百科和知乎上的文章的整理，也补充上了NP-C Problem的介绍。</b><br>P类问题：所有可以在多项式时间内求解的判定问题（返回一个yes/no）构成P类问题。比如验证一个数是否是质数，我们可以从2一直除到这个数本身来验证这个数有没有除了1和本身以外的factor。<br>NP类问题：所有非确定性多项式时间可解的判定问题构成NP类问题。比如在正整数集合中找到下一个质数。求解这个问题是不可以按部就班的解出来的，只能够靠猜或者是线性搜索。然而，验证一个数是否是质数是一个P问题。因此我们就有了下一个定义<br>NP-C问题：NP中的某些问题的复杂性与整个类的复杂性相关联。这些问题中任何一个如果存在多项式时间的算法，那么所有的问题都是多项式时间可解的。这些问题被称为NP-Complete问题。（即可以转换到一个关联的P问题）<br>人们发现，所有的完全多项式非确定性问题，都可以转换为一类满足性（验证）问题的逻辑运算问题。既然这类问题的所有可能答案都可以在多项时间内计算，人们就猜想，是否这类问题存在一个确定性的算法，可以在多项式时间内直接搜索出正确的答案，也就是所以P = NP这个假设是否成立呢？<br>举个例子，神经网络的optimization就是一个NP问题，我们可以用迭代的gradient descent不断向更优的方向逼近。然后用validation set验证结果的好坏。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.senevan.com/2019/02/08/2019-02-08/" data-id="ckmivlo1o0004f8og8to59b8c" data-title="[东拼西凑] P and NP" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post- 2019-01-19" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/19/%202019-01-19/" class="article-date">
  <time class="dt-published" datetime="2019-01-19T13:39:33.000Z" itemprop="datePublished">2019-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/19/%202019-01-19/">[有始无终] A Brief Introduction to Reinforcement Learning</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>（文章背景：19年我本来以为自己MSc的论文要写RL相关的题目，然而后面临时改成了CV相关。那时候询着Dr.Po的邮件看到了UT的RL公开课。看完第一个Introduction视频做的笔记。）<br>Some images or paragraph were cited from CS885 of Waterloo University. Thanks to Prof.Poupart for such an amazing course.</p>
<h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><ul>
<li>Introduction to Reinfocement Learning</li>
</ul>
<h2 id="Introduction-to-Reinforcement-Learning"><a href="#Introduction-to-Reinforcement-Learning" class="headerlink" title="Introduction to Reinforcement Learning"></a>Introduction to Reinforcement Learning</h2><h3 id="Old-paradigm-vs-New-Paradigm"><a href="#Old-paradigm-vs-New-Paradigm" class="headerlink" title="Old paradigm vs. New Paradigm"></a>Old paradigm vs. New Paradigm</h3><p>In the tradational computer science method, we need to program every action of computer. Because the progressive research of Machine Learning field, we can provide some examples to computer, making it learn to accomplish a task based on examples. That is generally called supervised (machine) learning.<br>However, to let machines learn a task need a lot of examples or data. We could label all of the data but that is so laborious. Alternatively, unsupervised learning or semi-supervised learning is more realistic and smart for huge mount of data. There is another method which neither supervised nor unspuervised, the reinforcement learning.</p>
<h3 id="What-is-Reinforcement-Learning"><a href="#What-is-Reinforcement-Learning" class="headerlink" title="What is Reinforcement Learning?"></a>What is Reinforcement Learning?</h3><p>Some well-known nickname, AKA  </p>
<ul>
<li>Optimal control</li>
<li>Approximate dynamic programming</li>
<li>Neuro-dynamic programming  </li>
</ul>
<p>Here is the definition from Wikipedia, you can read this paragrahph for a general view.<br>Reinforcement learning is an area of machine learning inspired by behavioural psychology, concerned with how software agents ought to take actions in an environment so as to maximize some notion of cumulative reward.<br>Just like the artifical neural network borrowed the concept of neuron. The reiforcement learning is alsor inspired from creatures.<br>If you want to train a dog to do some specific reactions, you need to reward it when the dog did the correct reactions, for example pleasure and food. On the opposite, some negative reward should be applied when the dog did bad. That is the basic idea to do reforcement for training a dog. If we do the similar things to a machine, that is so called reiforcement learning!  </p>
<h3 id="The-components-in-Reiforcement-Learning-Problem"><a href="#The-components-in-Reiforcement-Learning-Problem" class="headerlink" title="The components in Reiforcement Learning Problem"></a>The components in Reiforcement Learning Problem</h3><p>We need to train an agent instead of a dog for a general reinforcement learning task. So the first component should be the Agent. Except the agent, the all of other things are enviorment of the agent. The agent can change the state of environment by actions, then the environment feedback reward to agent, which is what a reinforcenemt learning system do.<br><a data-flickr-embed="true"  target="_blank" rel="noopener" href="https://www.flickr.com/photos/166826763@N02/46164422064/in/dateposted-public/" title="reiforcement learning"><img src="https://farm8.staticflickr.com/7811/46164422064_6006329497_b.jpg" width="1024" height="611" alt="reiforcement learning"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
<h3 id="Is-there-any-examples-of-RL"><a href="#Is-there-any-examples-of-RL" class="headerlink" title="Is there any examples of RL"></a>Is there any examples of RL</h3><p>Sure. You may know the famous system developed by DeepMind, the AlphaGO is totally benefited by reinforcement learning. If you are a video game fans you may know there is a competition for traininig an AI to battle with Starcraft. Here I list few task examples which applied or could apply reinforcement learning.</p>
<ul>
<li>Game Playing(Go, atari, Starcraft)</li>
<li>Operations research(pricing, veichle routing)</li>
<li>Elevator control</li>
<li>Motor balance control (RL instead of PID I think?)</li>
<li>Spoken dialog systems</li>
<li>Data center energy optimization (some company do this by RL and the result is pretty good)</li>
<li>Self-managing network systems</li>
<li>Autonomous Vehicles (I think it is not a good idea for autonomous car… maybe other vehicle)</li>
<li>Computation Finance (My research topics currently)  </li>
</ul>
<p>I would like to write more about the RL in Computational Finance.<br>In an automated trading system.</p>
<ul>
<li>Agent: Trading software(trading bot)</li>
<li>Environment: other traders and the market</li>
<li>State: Price history and current price</li>
<li>Action: basic stock actions, buy/sell/hold etc</li>
<li>Reward: The Profit. Money.  </li>
</ul>
<p>Definitely we want to maximize our PROFIT.</p>
<h3 id="Overview-of-the-RL"><a href="#Overview-of-the-RL" class="headerlink" title="Overview of the RL"></a>Overview of the RL</h3><p><b>Comprehensive, but challenging form of machine learning.</b>  </p>
<ul>
<li>Stochastic environment</li>
<li>Incomplete model (hardly to model but easy to behave by human)</li>
<li>Interdependent sequence if decision.</li>
<li>No supervision</li>
<li>Partial and delayed feedback (Some lag exists)  </li>
</ul>
<p><b>- Long term goal: lifelong machine learning</b><br>Thank you for reading.</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a target="_blank" rel="noopener" href="https://cs.uwaterloo.ca/~ppoupart/teaching/cs885-spring18/schedule.html">https://cs.uwaterloo.ca/~ppoupart/teaching/cs885-spring18/schedule.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.senevan.com/2019/01/19/%202019-01-19/" data-id="ckmivlo1m0003f8og1wbr6v1c" data-title="[有始无终] A Brief Introduction to Reinforcement Learning" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Anime/" rel="tag">Anime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-STL/" rel="tag">C++, STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-vcpkg-Notes/" rel="tag">C++, vcpkg, Notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPython-VM/" rel="tag">CPython, VM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CWE-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%8C%E8%BD%AC%E8%BD%BD/" rel="tag">CWE, 软件开发，转载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Life/" rel="tag">Life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UID-Work/" rel="tag">UID, Work</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%92%E6%A1%A3/" rel="tag">归档</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Anime/" style="font-size: 10px;">Anime</a> <a href="/tags/C-STL/" style="font-size: 10px;">C++, STL</a> <a href="/tags/C-vcpkg-Notes/" style="font-size: 10px;">C++, vcpkg, Notes</a> <a href="/tags/CPython-VM/" style="font-size: 10px;">CPython, VM</a> <a href="/tags/CWE-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%8C%E8%BD%AC%E8%BD%BD/" style="font-size: 10px;">CWE, 软件开发，转载</a> <a href="/tags/LeetCode/" style="font-size: 10px;">LeetCode</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Life/" style="font-size: 20px;">Life</a> <a href="/tags/Notes/" style="font-size: 20px;">Notes</a> <a href="/tags/UID-Work/" style="font-size: 10px;">UID, Work</a> <a href="/tags/%E5%BD%92%E6%A1%A3/" style="font-size: 10px;">归档</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/21/2021-03-21/">[转载归档]2020年最危险的软件缺陷</a>
          </li>
        
          <li>
            <a href="/2021/02/26/2021-02-26/">[开发环境]切换到vcpkg</a>
          </li>
        
          <li>
            <a href="/2021/02/23/2021-02-23/">[编程随记]CPython 中的小整数池的实现</a>
          </li>
        
          <li>
            <a href="/2021/02/02/2021-02-02/">[C++]实现std::move和std::forward</a>
          </li>
        
          <li>
            <a href="/2021/01/05/2021-01-02/">[南来北往]京沪卧铺动车乘坐体验</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Komoriii<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/About-Me" class="mobile-nav-link">About</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>